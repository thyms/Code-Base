To Cover
--------
- Process vs. Thread
- synchronized, volatile keywords
- Immutability & Defensive Copies(both for setting&getting fields)
- Threads & Thread Pools(Executor Framework)
- Runnable(Task), Thread(Worker), Callable(Task), Future(Result), FutureTask
- BlockingLinkedList, Non-BlockingLinkedList
- Thread: yield, sleep, interrupt, wait, notify, notifyAll, isAlive, setDaemon, isDaemon, stop(deprecated), suspend(deprecated), resume(deprecated)
- ThreadGroup
- Fairness, Starvation & Deadlock
- Selector???
- CyclicBarrier
- Runnable vs. Callable
- AutomicInteger, AutomicLong


Notes
-----
- Volatile: Ensures that the variable is loaded from memory before each use, and stored to memory after each use.
- Synchronized: Ensures that only a single thread can execute a block of code at the same time.
Prevents threads from updating the same value simultaneously, so that value won't be in an undefined or inconsistent state.
While a thread is inside a synchronized method of an object, all other threads that wish to execute this synchronized method 
or any other synchronized method of the object will have to wait until it gets the lock.
- A process is an instance of an running application. A process can have multiple threads.
  A Thread is the execution stream of the process.
  
The major difference between threads and processes is 

1.Threads(Light weight Processes) share the address space 
of the process that created it; processes have their own 
address
.2.Threads have direct access to the data segment of its 
process; processes have their own copy of the data segment 
of the parent process. 
3.Threads can directly communicate with other threads of 
its process; processes must use interprocess communication 
to communicate with sibling processes.
 4.Threads have almost no overhead; processes have 
considerable overhead.
5.New threads are easily created; new processes require 
duplication of the parent process.
6.Threads can exercise considerable control over threads of 
the same process; processes can only exercise control over 
child processes.
 7.Changes to the main thread (cancellation, priority 
change, etc.) may affect the behavior of the other threads 
of the process; changes to the parent process does not 
affect child processes.If we consider running a word 
processing program to be a process, then the auto-save and 
spell check features that occur in the background are 
different threads of that process which are all operating 
on the same data set (your document).


Process
An instance of a program; 
Executed in own address space
Independent entity to which system assigns resources CPU time, memory. 
Cannot access variables or other data structure in another process
Process communicate using inter-process mechanisms like files, pipes, sockets

Thread
Is a particular execution path thru a process.
Multiple threads can share state info of a single process.
Thread share memory and system resources.
Can communicate thru shared variables and other memory structures
Context switching is faster than process.


Thread:
- ... provides concurrent and asynchronous behavior.
- ... is an independent path of execution within a program.
- ... has its own call stack but access shared data.
- ... has its own memory cache.
- Each thread of the same program shares the same data area.
- ... is created by extending Thread or implementing Runnable.
- JVM has a "Thread Scheduler", process according to "Priority" & "Daemon Flag"
executes the thread with highest priority, makes JVM exit if there is no thread or 
only daemon threads.
- "Thread Scheduler" can be either "Preemptive" or "Non-Preemptive". 
Preemptive, each thread has a certain time-slice to execute.
Non-Preemptive, thread executes until it finishes its task.
The chosen thread will run until one of the following conditions is true:
	a higher priority thread becomes Runnable. (Pre-emptive scheduling)
	it yields, or its run() method exits
	on systems that support time-slicing, its time allotment has expired
- In Java, reading and writing a variable is atomic
Except long and double types, they have to be declared as volatile 

Concurrency:
- Running several parts of a program or same part in parallel.
- Executing more than one task at the same time within a program.

Asynchronous:
- Running part of a program in a asynchronous manner, e.g. responding the request at a later time

Process:
- each has different address space for both and data.
- resources(memory,cpu time) are allocated to it by operating system.


THREAD
------
public class Counter implements Runnable
{
        Thread T;                        
        public void run()                       
        {                              
        ....            
        }
}
----------------------------------------------------
----------------------------------------------------

public class SimpleThread extends Thread {
  private int countDown = 5;
  private static int threadCount = 0;
  public SimpleThread() {
    super("" + ++threadCount); // Store the thread name
    start();
  }
  public String toString() {
    return "#" + getName() + ": " + countDown;
  }
  public void run() {
    while(true) {
      System.out.println(this);
      if(--countDown == 0) return;
    }
  }
  public static void main(String[] args) {
    for(int i = 0; i < 5; i++)
      new SimpleThread();
  }
}
----------------------------------------------------
----------------------------------------------------


Thread myThread = new MyThreadClass();
myThread.start();
try {
    myThread.sleep(10000);
} catch (InterruptedException e){
}
----------------------------------------------------
----------------------------------------------------


Thread myThread = new MyThreadClass();
myThread.start();
try {
    Thread.currentThread().sleep(10000);
} catch (InterruptedException e){
}
----------------------------------------------------
----------------------------------------------------

class StackClass {

	private Object[] stackArray;
	private volatile int topOfStack;
	StackClass(int capacity) {
		stackArray = new Object[capacity];
		topOfStack = -1;
	}
	public synchronized Object pop() {
		System.out.println(Thread.currentThread() + ": popping");
		while (isEmpty()) {
			try {
				System.out.println(Thread.currentThread()
						+ ": waiting to pop");
				wait();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		Object obj = stackArray[topOfStack];
		stackArray[topOfStack--] = null;
		System.out.println(Thread.currentThread()
				+ ": notifying after pop");
		notify();
		return obj;
	}
	public synchronized void push(Object element) {
		System.out.println(Thread.currentThread() + ": pushing");
		while (isFull()) {
			try {
				System.out.println(Thread.currentThread()
						+ ": waiting to push");
				wait();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		stackArray[++topOfStack] = element;
		System.out.println(Thread.currentThread()
				+ ": notifying after push");
		notify();
	}
	public boolean isFull() {
		return topOfStack >= stackArray.length - 1;
	}
	public boolean isEmpty() {
		return topOfStack < 0;
	}
}

abstract class StackUser extends Thread {

	protected StackClass stack;
	StackUser(String threadName, StackClass stack) {
		super(threadName);
		this.stack = stack;
		System.out.println(this);
		setDaemon(true);
		start();
	}
}

class StackPopper extends StackUser { // Stack Popper

	StackPopper(String threadName, StackClass stack) {
		super(threadName, stack);
	}
	public void run() {
		while (true) {
			stack.pop();
		}
	}
}

class StackPusher extends StackUser { // Stack Pusher

	StackPusher(String threadName, StackClass stack) {
		super(threadName, stack);
	}
	public void run() {
		while (true) {
			stack.push(new Integer(1));
		}
	}
}

public class WaitAndNotifyExample {

	public static void main(String[] args) {
		StackClass stack = new StackClass(5);
		new StackPusher("One", stack);
		new StackPusher("Two", stack);
		new StackPopper("Three", stack);
		System.out.println("Main Thread sleeping.");
		try {
			Thread.sleep(500);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println("Exit from Main Thread.");
	}
}
----------------------------------------------------
----------------------------------------------------


public class WorkQueue
{
    private final int nThreads;
    private final PoolWorker[] threads;
    private final LinkedList queue;

    public WorkQueue(int nThreads)
    {
        this.nThreads = nThreads;
        queue = new LinkedList();
        threads = new PoolWorker[nThreads];

        for (int i=0; i<nThreads; i++) {
            threads[i] = new PoolWorker();
            threads[i].start();
        }
    }

    public void execute(Runnable r) {
        synchronized(queue) {
            queue.addLast(r);
            queue.notify();
        }
    }

    private class PoolWorker extends Thread {
        public void run() {
            Runnable r;

            while (true) {
                synchronized(queue) {
                    while (queue.isEmpty()) {
                        try
                        {
                            queue.wait();
                        }
                        catch (InterruptedException ignored)
                        {
                        }
                    }

                    r = (Runnable) queue.removeFirst();
                }

                // If we don't catch RuntimeException, 
                // the pool could leak threads
                try {
                    r.run();
                }
                catch (RuntimeException e) {
                    // You might want to log something here
                }
            }
        }
    }
}


----------------------------------------------------
----------------------------------------------------


public class MyRunnable implements Runnable {
	private final long countUntil;

	MyRunnable(long countUntil) {
		this.countUntil = countUntil;
	}

	@Override
	public void run() {
		long sum = 0;
		for (long i = 1; i < countUntil; i++) {
			sum += i;
		}
		System.out.println(sum);
	}
}

public class Main {

	public static void main(String[] args) {
		// We will store the threads so that we can check if they are done
		List<Thread> threads = new ArrayList<Thread>();
		// We will create 500 threads
		for (int i = 0; i < 500; i++) {
			Runnable task = new MyRunnable(10000000L + i);
			Thread worker = new Thread(task);
			// We can set the name of the thread
			worker.setName(String.valueOf(i));
			// Start the thread, never call method run() direct
			worker.start();
			// Remember the thread for later usage
			threads.add(worker);
		}
		int running = 0;
		do {
			running = 0;
			for (Thread thread : threads) {
				if (thread.isAlive()) {
					running++;
				}
			}
			System.out.println("We have " + running + " running threads. ");
		} while (running > 0);

	}
}
----------------------------------------------------
----------------------------------------------------


class TwoThreadsTest {
    public static void main (String args[]) {
        new SimpleThread("Jamaica").start();
        new SimpleThread("Fiji").start();
    }
}
class SimpleThread extends Thread {
    public SimpleThread(String str) {
	super(str);
    }
    public void run() {
	for (int i = 0; i < 10; i++) {
	    System.out.println(i + " " + getName());
            try {
		sleep((int)(Math.random() * 1000));
	    } catch (InterruptedException e) {}
	}
	System.out.println("DONE! " + getName());
    }
}
----------------------------------------------------
----------------------------------------------------

class ProducerConsumerTest {
    public static void main(String args[]) {
	CubbyHole c = new CubbyHole();
	Producer p1 = new Producer(c, 1);
	Consumer c1 = new Consumer(c, 1);

        p1.start();
        c1.start();
    }
}

class Producer extends Thread {
    private CubbyHole cubbyhole;
    private int number;

    public Producer(CubbyHole c, int number) {
	cubbyhole = c;
	this.number = number;
    }

    public void run() {
	for (int i = 0; i < 10; i++) {
	    cubbyhole.put(i);
	    System.out.println("Producer #" + this.number + " put: " + i);
	    try {
	        sleep((int)(Math.random() * 100));
	    } catch (InterruptedException e) {
	    }
	}
    }
}

class Consumer extends Thread {
    private CubbyHole cubbyhole;
    private int number;

    public Consumer(CubbyHole c, int number) {
	cubbyhole = c;
	this.number = number;
    }

    public void run() {
	int value = 0;
	for (int i = 0; i < 10; i++) {
	    value = cubbyhole.get();
	    System.out.println("Consumer #" + this.number + " got: " + value);
	}
    }
}

// It might be better to use "synchronized block here"
// instead of using wait/notify mechanism
class CubbyHole {
    private int seq;
    private boolean available = false;

    public synchronized int get() {
        while (available == false) {
	    try {
			wait();
	    } catch (InterruptedException e) {
	    }
	}
        available = false;
		notify();
		return seq;
    }

    public synchronized void put(int value) {
	while (available == true) {
	    try {
			wait();
	    } catch (InterruptedException e) {
	    }
	}
		seq = value;
        available = true;
        notify();
    }
}
----------------------------------------------------
----------------------------------------------------

class RunnableThread implements Runnable {

	Thread runner;
	public RunnableThread() {
	}
	public RunnableThread(String threadName) {
		runner = new Thread(this, threadName); // (1) Create a new thread.
		System.out.println(runner.getName());
		runner.start(); // (2) Start the thread.
	}
	public void run() {
		//Display info about this particular thread
		System.out.println(Thread.currentThread());
	}
}

public class RunnableExample {

	public static void main(String[] args) {
		Thread thread1 = new Thread(new RunnableThread(), "thread1");
		Thread thread2 = new Thread(new RunnableThread(), "thread2");
		RunnableThread thread3 = new RunnableThread("thread3");
		//Start the threads
		thread1.start();
		thread2.start();
		try {
			//delay for one second
			Thread.currentThread().sleep(1000);
		} catch (InterruptedException e) {
		}
		//Display info about the main thread
		System.out.println(Thread.currentThread());
	}
}
----------------------------------------------------
----------------------------------------------------


THREAD GROUP
------------
ThreadGroup myThreadGroup = new ThreadGroup("My Group of Threads");
Thread myThread = new Thread(myThreadGroup, "a thread for my group");
----------------------------------------------------
----------------------------------------------------


SYNCHRONIZED
------------
public class CrawledSites {
	private List<String> crawledSites = new ArrayList<String>();
	private List<String> linkedSites = new ArrayList<String>();

	public void add(String site) {
		synchronized (this) {
			if (!crawledSites.contains(site)) {
				linkedSites.add(site);
			}
		}
	}
}
----------------------------------------------------
----------------------------------------------------


public class A {
	static void classAction() {
		synchronized (A.class) { // Synchronized block on class A
			// …
		}
	}
}
same as below...


public class A {
	static synchronized  void classAction() {
			// …
	}
}
----------------------------------------------------
----------------------------------------------------


VOLATILE
--------
public class RunnerMisc {
	private static volatile Customer customer = new Customer();
	private static volatile int count = 10;
}
----------------------------------------------------
----------------------------------------------------


JOIN
----
public class ThreadJoinDemo {

	public static void main(String[] args) {
		Thread t1 = new Thread("T1");
		Thread t2 = new Thread("T2");
		try {
			System.out.println("Wait for the child threads to finish.");
			t1.join();	// Current thread is waiting for t1 to finish its execution
			if (!t1.isAlive())
				System.out.println("Thread T1 is not alive.");
			t2.join(); // Current thread is waiting for t2 to finish its execution
			if (!t2.isAlive())
				System.out.println("Thread T2 is not alive.");
		} catch (InterruptedException e) {
			System.out.println("Main Thread interrupted.");
		}
		System.out.println("Exit from Main Thread.");
	}
}
----------------------------------------------------
----------------------------------------------------


IMMUTABLE & DEFENSIVE COPIES
----------------------------
public class MyDataStructure {
	List<String> list = new ArrayList<String>();

	public void add(String s) {
		list.add(s);
	}

	public List<String> getList() {
		return Collections.unmodifiableList(list);
	}
}
----------------------------------------------------
----------------------------------------------------


EXECUTOR FRAMEWORK
------------------
public class Main {
	private static final int NTHREDS = 10;

	public static void main(String[] args) {
		ExecutorService executor = Executors.newFixedThreadPool(NTHREDS);
		for (int i = 0; i < 500; i++) {
			Runnable worker = new MyRunnable(10000000L + i);
			executor.execute(worker);
		}
		// This will make the executor accept no new threads
		// and finish all existing threads in the queue
		executor.shutdown();
		// Wait until all threads are finish
		while (!executor.isTerminated()) {

		}
		System.out.println("Finished all threads");
	}
}

public class MyRunnable implements Runnable {
	private final long countUntil;

	MyRunnable(long countUntil) {
		this.countUntil = countUntil;
	}

	@Override
	public void run() {
		long sum = 0;
		for (long i = 1; i < countUntil; i++) {
			sum += i;
		}
		System.out.println(sum);
	}
}
----------------------------------------------------
----------------------------------------------------


FUTURE & CALLABLE
-----------------
public class CallableFutures {
	private static final int NTHREDS = 10;

	public static void main(String[] args) {

		ExecutorService executor = Executors.newFixedThreadPool(NTHREDS);
		List<Future<Long>> list = new ArrayList<Future<Long>>();
		for (int i = 0; i < 20000; i++) {
			Callable<Long> worker = new MyCallable();
			Future<Long> submit = executor.submit(worker);
			list.add(submit);
		}
		long sum = 0;
		System.out.println(list.size());
		// Now retrieve the result
		for (Future<Long> future : list) {
			try {
				sum += future.get();
			} catch (InterruptedException e) {
				e.printStackTrace();
			} catch (ExecutionException e) {
				e.printStackTrace();
			}
		}
		System.out.println(sum);
		executor.shutdown();
	}
}

public class MyCallable implements Callable<Long> {
	@Override
	public Long call() throws Exception {
		long sum = 0;
		for (long i = 0; i <= 100; i++) {
			sum += i;
		}
		return sum;
	}

}
----------------------------------------------------
----------------------------------------------------


ATOMIC INTEGER
--------------
public class Counter {
	private AtomicInteger value = new AtomicInteger(); 
	public int getValue(){
		return value.get();
	}
	public int increment(){
		return value.incrementAndGet();
	}
	
	// Alternative implementation as increment but just make the 
	// implementation explicit
	public int incrementLongVersion(){
		int oldValue = value.get();
		while (value.compareAndSet(oldValue, oldValue+1)){
			 oldValue = value.get();
		}
		return oldValue+1;
	}
}

public class Test {
		private static final int NTHREDS = 10;

		public static void main(String[] args) {
			final Counter counter = new Counter();
			List<Future<Integer>> list = new ArrayList<Future<Integer>>();

			ExecutorService executor = Executors.newFixedThreadPool(NTHREDS);
			for (int i = 0; i < 500; i++) {
				Callable<Integer> worker = new  Callable<Integer>() {
					@Override
					public Integer call() throws Exception {
						int number = counter.increment();
						System.out.println(number );
						return number ;
					}
				};
				Future<Integer> submit= executor.submit(worker);
				list.add(submit);

			}
			
			
			// This will make the executor accept no new threads
			// and finish all existing threads in the queue
			executor.shutdown();
			// Wait until all threads are finish
			while (!executor.isTerminated()) {
			}
			Set<Integer> set = new HashSet<Integer>();
			for (Future<Integer> future : list) {
				try {
					set.add(future.get());
				} catch (InterruptedException e) {
					e.printStackTrace();
				} catch (ExecutionException e) {
					e.printStackTrace();
				}
			}
			if (list.size()!=set.size()){
				throw new RuntimeException("Double-entries!!!"); 
			}
		}
}
----------------------------------------------------
----------------------------------------------------


CYCLIC BARRIER
--------------
public class SimpleThread extends Thread {
	private int countDown = 5;
	private static CyclicBarrier cyclicBarrier;
	private static int threadCount = 0;

	public SimpleThread() {
		super("" + ++threadCount); // Store the thread name
		start();
	}

	public String toString() {
		return "#" + getName() + ": " + countDown;
	}

	public void run() {
		try {
			cyclicBarrier.await();
		} catch (InterruptedException e) {
			e.printStackTrace();
		} catch (BrokenBarrierException e) {
			e.printStackTrace();
		}

		while (true) {
			System.out.println(this);
			if (--countDown == 0)
				return;
		}
	}

	public static void main(String[] args) {
		cyclicBarrier = new CyclicBarrier(5);

		for (int i = 0; i < 5; i++)
			new SimpleThread();
	}
}
----------------------------------------------------
----------------------------------------------------


DEADLOCK
--------
public class DeadLockExample {

	String o1 = "Lock ";
	String o2 = "Step ";
	Thread t1 = (new Thread("Printer1") {

		public void run() {
			while (true) {
				synchronized (o1) {
					synchronized (o2) {
						System.out.println(o1 + o2);
					}
				}
			}
		}
	});
	Thread t2 = (new Thread("Printer2") {

		public void run() {
			while (true) {
				synchronized (o2) {
					synchronized (o1) {
						System.out.println(o2 + o1);
					}
				}
			}
		}
	});
	public static void main(String[] args) {
		DeadLockExample dLock = new DeadLockExample();
		dLock.t1.start();
		dLock.t2.start();
	}
}
----------------------------------------------------
----------------------------------------------------