To Cover
--------
- Process vs. Thread
- synchronized, volatile keywords
- Immutability & Defensive Copies(both for setting&getting fields)
- Threads & Thread Pools(Executor Framework)
- Runnable(Task), Thread(Worker), Callable(Task), Future(Result), FutureTask
- BlockingLinkedList, Non-BlockingLinkedList
- Thread: yield, sleep, interrupt, wait, notify, notifyAll, isAlive, setDaemon, isDaemon, stop(deprecated), suspend(deprecated), resume(deprecated)
- ThreadGroup
- Fairness, Starvation & Deadlock
- Selector???
- CyclicBarrier
- CountDownLatch
- Runnable vs. Callable
- AutomicInteger, AutomicLong


Notes
-----
- Volatile: Ensures that the variable is loaded from memory before each use, and stored to memory after each use.
- Synchronized: Ensures that only a single thread can execute a block of code at the same time.
Prevents threads from updating the same value simultaneously, so that value won't be in an undefined or inconsistent state.
While a thread is inside a synchronized method of an object, all other threads that wish to execute this synchronized method 
or any other synchronized method of the object will have to wait until it gets the lock.
- A process is an instance of an running application. A process can have multiple threads.
  A Thread is the execution stream of the process.
  
The major difference between threads and processes is 
1.Threads(Light weight Processes) share the address space 
of the process that created it; processes have their own 
address
.2.Threads have direct access to the data segment of its 
process; processes have their own copy of the data segment 
of the parent process. 
3.Threads can directly communicate with other threads of 
its process; processes must use interprocess communication 
to communicate with sibling processes.
 4.Threads have almost no overhead; processes have 
considerable overhead.
5.New threads are easily created; new processes require 
duplication of the parent process.
6.Threads can exercise considerable control over threads of 
the same process; processes can only exercise control over 
child processes.
 7.Changes to the main thread (cancellation, priority 
change, etc.) may affect the behavior of the other threads 
of the process; changes to the parent process does not 
affect child processes.If we consider running a word 
processing program to be a process, then the auto-save and 
spell check features that occur in the background are 
different threads of that process which are all operating 
on the same data set (your document).


Process
An instance of a program; 
Executed in own address space
Independent entity to which system assigns resources CPU time, memory. 
Cannot access variables or other data structure in another process
Process communicate using inter-process mechanisms like files, pipes, sockets

Thread
Is a particular execution path thru a process.
Multiple threads can share state info of a single process.
Thread share memory and system resources.
Can communicate thru shared variables and other memory structures
Context switching is faster than process.


Thread:
- ... provides concurrent and asynchronous behavior.
- ... is an independent path of execution within a program.
- ... has its own call stack but access shared data.
- ... has its own memory cache.
- Each thread of the same program shares the same data area.
- ... is created by extending Thread or implementing Runnable.
- JVM has a "Thread Scheduler", process according to "Priority" & "Daemon Flag"
executes the thread with highest priority, makes JVM exit if there is no thread or 
only daemon threads.
- "Thread Scheduler" can be either "Preemptive" or "Non-Preemptive". 
Preemptive, each thread has a certain time-slice to execute.
Non-Preemptive, thread executes until it finishes its task.
The chosen thread will run until one of the following conditions is true:
	a higher priority thread becomes Runnable. (Pre-emptive scheduling) 
	it yields, or its run() method exits
	on systems that support time-slicing, its time allotment has expired
Thread.MIN_PRIORITY(1), Thread.NORM_PRIORITY(5), Thread.MAX_PRIORITY(10) 
- In Java, reading and writing a variable is atomic
Except long and double types, they have to be declared as volatile 
- while sleeping, the thread still owns synchronization locks it has acquired;

Concurrency:
- Running several parts of a program or same part in parallel.
- Executing more than one task at the same time within a program.

Asynchronous:
- Running part of a program in a asynchronous manner, e.g. responding the request at a later time

Process:
- each has different address space for both and data.
- resources(memory,cpu time) are allocated to it by operating system.

Java Thread Memory Model:
each program has an area of main memory where it stores it's classes, arrays and variables
the main memory has a master copy of every variable and contains one lock for each object
this main memory area is accessible by all the programs threads
threads can only communicate thru the shared main memory
each thread has a working memory where it keeps copies of the values of variables it uses or assigns
to access a shared variable, a thread obtains a lock and flushes its working memory, guaranteeing the shared value will be loaded from main memory
as a thread executes, it operates on its working copies
when a synchronized block or method is entered, actions by the thread and main memory must occur in a specific order
1. the thread obtains a lock on the object and flushes its working copy of the object
2. main memory reads the objects value from it's master copy
- the thread loads the value passed by the main memorys read operation
- the thread uses it's working copy of the object, passing it to it's excuatable engine
- the thread assigns the resulting value back to it's working copy
- the thread stores the new value, passing it back to main memory
3. main memory writes the value passed by the threads store action back to the master copy
4. the thread releases it's lock on the object

THREAD
------
public class Counter implements Runnable
{
        Thread T;                        
        public void run()                       
        {                              
        ....            
        }
}
----------------------------------------------------
----------------------------------------------------

public class SimpleThread extends Thread {
  private int countDown = 5;
  private static int threadCount = 0;
  public SimpleThread() {
    super("" + ++threadCount); // Store the thread name
    start();
  }
  public String toString() {
    return "#" + getName() + ": " + countDown;
  }
  public void run() {
    while(true) {
      System.out.println(this);
      if(--countDown == 0) return;
    }
  }
  public static void main(String[] args) {
    for(int i = 0; i < 5; i++)
      new SimpleThread();
  }
}
----------------------------------------------------
----------------------------------------------------


public class RunnableThread implements Runnable {
  private int countDown = 5;
  public String toString() {
    return "#" + Thread.currentThread().getName() +
      ": " + countDown;
  }
  public void run() {
    while(true) {
      System.out.println(this);
      if(--countDown == 0) return;
    }
  }
  public static void main(String[] args) {
    for(int i = 1; i <= 5; i++)
      new Thread(new RunnableThread(), "" + i).start();
    // Output is like SimpleThread.java
  }
}
----------------------------------------------------
----------------------------------------------------


class MyThread implements Runnable {
  int count;

  MyThread() {
    count = 0;
  }
  public void run() {
    System.out.println("MyThread starting.");
    try {
      do {
        Thread.sleep(500);
        System.out.println("In MyThread, count is " + count);
        count++;
      } while (count < 5);
    } catch (InterruptedException exc) {
      System.out.println("MyThread interrupted.");
    }
    System.out.println("MyThread terminating.");
  }
}

class RunnableDemo {
  public static void main(String args[]) {
    System.out.println("Main thread starting.");
    MyThread mt = new MyThread();
    Thread newThrd = new Thread(mt);
    newThrd.start();
    do {
      System.out.println("In main thread.");
      try {
        Thread.sleep(250);
      } catch (InterruptedException exc) {
        System.out.println("Main thread interrupted.");
      }
    } while (mt.count != 5);

    System.out.println("Main thread ending.");
  }
}
----------------------------------------------------
----------------------------------------------------


class MyThread extends Thread {
  int count;

  MyThread() {
    count = 0;
  }

  public void run() {
    System.out.println("MyThread starting.");
    try {
      do {
        Thread.sleep(500);
        System.out.println("In MyThread, count is " + count);
        count++;
      } while (count < 5);
    } catch (InterruptedException exc) {
      System.out.println("MyThread interrupted.");
    }
    System.out.println("MyThread terminating.");
  }
}

public class Main {
  public static void main(String args[]) {
    System.out.println("Main thread starting.");
    MyThread mt = new MyThread();
    mt.start();
    do {
      System.out.println("In main thread.");
      try {
        Thread.sleep(250);
      } catch (InterruptedException exc) {
        System.out.println("Main thread interrupted.");
      }
    } while (mt.count != 5);
    System.out.println("Main thread ending.");
  }
}
----------------------------------------------------
----------------------------------------------------


Thread myThread = new MyThreadClass();
myThread.start();
try {
    myThread.sleep(10000);
} catch (InterruptedException e){
}
// Try and see InterruptedException is thrown
// when myThread is interrupted.
----------------------------------------------------
----------------------------------------------------


Thread myThread = new MyThreadClass();
myThread.start();
try {
    Thread.currentThread().sleep(10000);
} catch (InterruptedException e){
}
----------------------------------------------------
----------------------------------------------------


class LowPriority {
    public static void main(String[] args) {
        MyThread t1 = new MyThread(1);
        MyThread t2 = new MyThread(2);
        
        t1.setPriority(Thread.MAX_PRIORITY);
        t2.setPriority(Thread.MIN_PRIORITY);
        t1.start();
        t2.start();
    }
}   

class MyThread extends Thread {
    int id;
    
    MyThread(int id) {
        this.id = id;    
    }
    
    public void run(){
        for(int i=0; i<10; i++)
            System.out.println("My id is: " + id);
    }
}

----------------------------------------------------
----------------------------------------------------
/** Based on example from Sun Thread tutorial */
// Reentrant lock, which means sync methods can be invoked 
// in the same class, ones the lock is acquired.
class Reentrant {

  public synchronized void a() {
      b();
      System.out.println("here I am, in a()");
  }
  public synchronized void b() {
      System.out.println("here I am, in b()");
  }
}

class TestReentrant {
    public static void main(String[] args) {
        Reentrant r = new Reentrant();
        r.a();
    }
}

----------------------------------------------------
----------------------------------------------------

class StackClass {

	private Object[] stackArray;
	private volatile int topOfStack;
	StackClass(int capacity) {
		stackArray = new Object[capacity];
		topOfStack = -1;
	}
	public synchronized Object pop() {
		System.out.println(Thread.currentThread() + ": popping");
		while (isEmpty()) {
			try {
				System.out.println(Thread.currentThread()
						+ ": waiting to pop");
				wait();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		Object obj = stackArray[topOfStack];
		stackArray[topOfStack--] = null;
		System.out.println(Thread.currentThread()
				+ ": notifying after pop");
		notify();
		return obj;
	}
	public synchronized void push(Object element) {
		System.out.println(Thread.currentThread() + ": pushing");
		while (isFull()) {
			try {
				System.out.println(Thread.currentThread()
						+ ": waiting to push");
				wait();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		stackArray[++topOfStack] = element;
		System.out.println(Thread.currentThread()
				+ ": notifying after push");
		notify();
	}
	public boolean isFull() {
		return topOfStack >= stackArray.length - 1;
	}
	public boolean isEmpty() {
		return topOfStack < 0;
	}
}

abstract class StackUser extends Thread {

	protected StackClass stack;
	StackUser(String threadName, StackClass stack) {
		super(threadName);
		this.stack = stack;
		System.out.println(this);
		setDaemon(true);
		start();
	}
}

class StackPopper extends StackUser { // Stack Popper

	StackPopper(String threadName, StackClass stack) {
		super(threadName, stack);
	}
	public void run() {
		while (true) {
			stack.pop();
		}
	}
}

class StackPusher extends StackUser { // Stack Pusher

	StackPusher(String threadName, StackClass stack) {
		super(threadName, stack);
	}
	public void run() {
		while (true) {
			stack.push(new Integer(1));
		}
	}
}

public class WaitAndNotifyExample {

	public static void main(String[] args) {
		StackClass stack = new StackClass(5);
		new StackPusher("One", stack);
		new StackPusher("Two", stack);
		new StackPopper("Three", stack);
		System.out.println("Main Thread sleeping.");
		try {
			Thread.sleep(500);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println("Exit from Main Thread.");
	}
}
----------------------------------------------------
----------------------------------------------------


public class WorkQueue
{
    private final int nThreads;
    private final PoolWorker[] threads;
    private final LinkedList queue;

    public WorkQueue(int nThreads)
    {
        this.nThreads = nThreads;
        queue = new LinkedList();
        threads = new PoolWorker[nThreads];

        for (int i=0; i<nThreads; i++) {
            threads[i] = new PoolWorker();
            threads[i].start();
        }
    }

    public void execute(Runnable r) {
        synchronized(queue) {
            queue.addLast(r);
            queue.notify();
        }
    }

    private class PoolWorker extends Thread {
        public void run() {
            Runnable r;

            while (true) {
                synchronized(queue) {
                    while (queue.isEmpty()) {
                        try
                        {
                            queue.wait();
                        }
                        catch (InterruptedException ignored)
                        {
                        }
                    }

                    r = (Runnable) queue.removeFirst();
                }

                // If we don't catch RuntimeException, 
                // the pool could leak threads
                try {
                    r.run();
                }
                catch (RuntimeException e) {
                    // You might want to log something here
                }
            }
        }
    }
}
----------------------------------------------------
----------------------------------------------------


public class MyRunnable implements Runnable {
	private final long countUntil;

	MyRunnable(long countUntil) {
		this.countUntil = countUntil;
	}

	@Override
	public void run() {
		long sum = 0;
		for (long i = 1; i < countUntil; i++) {
			sum += i;
		}
		System.out.println(sum);
	}
}

public class Main {

	public static void main(String[] args) {
		// We will store the threads so that we can check if they are done
		List<Thread> threads = new ArrayList<Thread>();
		// We will create 500 threads
		for (int i = 0; i < 500; i++) {
			Runnable task = new MyRunnable(10000000L + i);
			Thread worker = new Thread(task);
			// We can set the name of the thread
			worker.setName(String.valueOf(i));
			// Start the thread, never call method run() direct
			worker.start();
			// Remember the thread for later usage
			threads.add(worker);
		}
		int running = 0;
		do {
			running = 0;
			for (Thread thread : threads) {
				if (thread.isAlive()) {
					running++;
				}
			}
			System.out.println("We have " + running + " running threads. ");
		} while (running > 0);

	}
}
----------------------------------------------------
----------------------------------------------------


class TwoThreadsTest {
    public static void main (String args[]) {
        new SimpleThread("Jamaica").start();
        new SimpleThread("Fiji").start();
    }
}
class SimpleThread extends Thread {
    public SimpleThread(String str) {
	super(str);
    }
    public void run() {
	for (int i = 0; i < 10; i++) {
	    System.out.println(i + " " + getName());
            try {
		sleep((int)(Math.random() * 1000));
	    } catch (InterruptedException e) {}
	}
	System.out.println("DONE! " + getName());
    }
}
----------------------------------------------------
----------------------------------------------------

class ProducerConsumerTest {
    public static void main(String args[]) {
	CubbyHole c = new CubbyHole();
	Producer p1 = new Producer(c, 1);
	Consumer c1 = new Consumer(c, 1);

        p1.start();
        c1.start();
    }
}

class Producer extends Thread {
    private CubbyHole cubbyhole;
    private int number;

    public Producer(CubbyHole c, int number) {
	cubbyhole = c;
	this.number = number;
    }

    public void run() {
	for (int i = 0; i < 10; i++) {
	    cubbyhole.put(i);
	    System.out.println("Producer #" + this.number + " put: " + i);
	    try {
	        sleep((int)(Math.random() * 100));
	    } catch (InterruptedException e) {
	    }
	}
    }
}

class Consumer extends Thread {
    private CubbyHole cubbyhole;
    private int number;

    public Consumer(CubbyHole c, int number) {
	cubbyhole = c;
	this.number = number;
    }

    public void run() {
	int value = 0;
	for (int i = 0; i < 10; i++) {
	    value = cubbyhole.get();
	    System.out.println("Consumer #" + this.number + " got: " + value);
	}
    }
}

// It might be better to use "synchronized block here"
// instead of using wait/notify mechanism
class CubbyHole {
    private int seq;
    private boolean available = false;

    public synchronized int get() {
        while (available == false) {
	    try {
			wait();
	    } catch (InterruptedException e) {
	    }
	}
        available = false;
		notify();
		return seq;
    }

    public synchronized void put(int value) {
	while (available == true) {
	    try {
			wait();
	    } catch (InterruptedException e) {
	    }
	}
		seq = value;
        available = true;
        notify();
    }
}
----------------------------------------------------
----------------------------------------------------

class RunnableThread implements Runnable {

	Thread runner;
	public RunnableThread() {
	}
	public RunnableThread(String threadName) {
		runner = new Thread(this, threadName); // (1) Create a new thread.
		System.out.println(runner.getName());
		runner.start(); // (2) Start the thread.
	}
	public void run() {
		//Display info about this particular thread
		System.out.println(Thread.currentThread());
	}
}

public class RunnableExample {

	public static void main(String[] args) {
		Thread thread1 = new Thread(new RunnableThread(), "thread1");
		Thread thread2 = new Thread(new RunnableThread(), "thread2");
		RunnableThread thread3 = new RunnableThread("thread3");
		//Start the threads
		thread1.start();
		thread2.start();
		try {
			//delay for one second
			Thread.currentThread().sleep(1000);
		} catch (InterruptedException e) {
		}
		//Display info about the main thread
		System.out.println(Thread.currentThread());
	}
}
----------------------------------------------------
----------------------------------------------------

// Yielding
public class YieldingThread extends Thread {

  private int countDown = 5;

  private static int threadCount = 0;

  public YieldingThread() {
    super("" + ++threadCount);
    start();
  }

  public String toString() {
    return "#" + getName() + ": " + countDown;
  }

  public void run() {
    while (true) {
      System.out.println(this);
      if (--countDown == 0)
        return;
      yield();
    }
  }

  public static void main(String[] args) {
    for (int i = 0; i < 5; i++)
      new YieldingThread();
  }
}
----------------------------------------------------
----------------------------------------------------


// Safe way to stop a thread
class CanStop extends Thread {
  // Must be volatile:
  private volatile boolean stop = false;

  private int counter = 0;

  public void run() {
    while (!stop && counter < 10000) {
      System.out.println(counter++);
    }
    if (stop)
      System.out.println("Detected stop");
  }

  public void requestStop() {
    stop = true;
  }
}

public class Stopping {
  public static void main(String[] args) {
    final CanStop stoppable = new CanStop();
    stoppable.start();
    new Timer(true).schedule(new TimerTask() {
      public void run() {
        System.out.println("Requesting stop");
        stoppable.requestStop();
      }
    }, 500); // run() after 500 milliseconds
  }
}
----------------------------------------------------
----------------------------------------------------


public class TwoThread extends Thread {
  private Thread creatorThread;

  public TwoThread() {
    creatorThread = Thread.currentThread(); // This is the important stuff, rest is normal stuff.
  }

  public void run() {
    for ( int i = 0; i < 10; i++ ) {
      printMsg();
    }
  }

  public void printMsg() {
    Thread t = Thread.currentThread();

    if ( t == creatorThread ) {
      System.out.println("Creator thread");
    } else if ( t == this ) {
      System.out.println("New thread");
    } else {
      System.out.println("Unexpected threads!");
    }
  }

  public static void main(String[] args) {
    TwoThread tt = new TwoThread();
    tt.start();

    for ( int i = 0; i < 10; i++ ) {
      tt.printMsg();
    }
  }
}
----------------------------------------------------
----------------------------------------------------


// Thread leakage handling - uncaughtException!!!
public class TestOverrideThread implements Runnable {

    static class OverrideExceptionHandler implements Thread.UncaughtExceptionHandler {
        public void uncaughtException(Thread t, Throwable e) {
            alertAdministrator(e);
        }
    }

    public static void alertAdministrator(Throwable e) {
        // Use Java Mail to send the administrator's pager an email
        System.out.println("Adminstrator alert!");
        e.printStackTrace();
    }

    public static void main(String[] args) {
        Thread t = new Thread(new TestOverrideThread());
        t.setUncaughtExceptionHandler(new OverrideExceptionHandler());
        System.out.println(t.getUncaughtExceptionHandler());
        t.start();
    }

    public void run() {
        ArrayList al = new ArrayList();
        while (true) {
            al.add(new byte[1024]);
        }
    }
}
----------------------------------------------------
----------------------------------------------------


// Determining If the Current Thread Is Holding a Synchronized Lock
public synchronized void myMethod() {
    boolean hasLock = false;
    Object o = new Object();

    // Determine if current thread has lock for o
    hasLock = Thread.holdsLock(o);     // false
    synchronized (o) {
        hasLock = Thread.holdsLock(o); // true
    }

    // Check if current thread has lock for current object
    hasLock = Thread.holdsLock(this);  // true
}
----------------------------------------------------
----------------------------------------------------

// Implementing an Unbounded Work Queue
// Create the work queue
WorkQueue queue = new WorkQueue();

// Create a set of worker threads
final int numWorkers = 2;
Worker[] workers = new Worker[numWorkers];
for (int i=0; i<workers.length; i++) {
    workers[i] = new Worker(queue);
    workers[i].start();
}

// Add some work to the queue; block if the queue is full.
// Note that null cannot be added to a blocking queue.
for (int i=0; i<100; i++) {
    queue.addWork(i);
}

// Add special end-of-stream markers to terminate the workers
for (int i=0; i<workers.length; i++) {
    queue.addWork(Worker.NO_MORE_WORK);
}


public class WorkQueue {
    LinkedList queue = new LinkedList();

    // Add work to the work queue
    public synchronized void addWork(Object o) {
        queue.addLast(o);
        notify();
    }

    // Retrieve work from the work queue; block if the queue is empty
    public synchronized Object getWork() throws InterruptedException {
        while (queue.isEmpty()) {
            wait();
        }
        return queue.removeFirst();
    }
}


class Worker extends Thread {
    // Special end-of-stream marker. If a worker retrieves
    // an Integer that equals this marker, the worker will terminate.
    static final Object NO_MORE_WORK = new Object();

    WorkQueue q;

    Worker(WorkQueue q) {
        this.q = q;
    }
    public void run() {
        try {
            while (true) {
                // Retrieve some work; block if the queue is empty
                Object x = q.getWork();

                // Terminate if the end-of-stream marker was retrieved
                if (x == NO_MORE_WORK) {
                    break;
                }

                // Compute the square of x
                int y = ((Integer)x).intValue() * ((Integer)x).intValue();
            }
        } catch (InterruptedException e) {
        }
    }
}
----------------------------------------------------
----------------------------------------------------


// Stopping a Thread
MyThread thread = new MyThread();
thread.start();

// Do work...

// Stop the thread
thread.allDone = true;

class MyThread extends Thread {
    boolean allDone = false;

    // This method is called when the thread runs
    public void run() {
        while (true) {
            // Do work...

            if (allDone) {
                return;
            }

            // Do work...
        }
    }
}
----------------------------------------------------
----------------------------------------------------


THREAD GROUP
------------
ThreadGroup myThreadGroup = new ThreadGroup("My Group of Threads");
Thread myThread = new Thread(myThreadGroup, "a thread for my group");
----------------------------------------------------
----------------------------------------------------


// Thread leakage handling - uncaughtException!!!
public class ThreadGroupExample {

    public static class MyThreadGroup extends ThreadGroup {

        public MyThreadGroup(String s) {
            super(s);
        }

		@Override
        public void uncaughtException(Thread thread, Throwable throwable) {
            System.out.println("Thread " + thread.getName() 
              + " died, exception was: ");
            throwable.printStackTrace();
        }
    }

    public static ThreadGroup workerThreads = 
      new MyThreadGroup("Worker Threads");

    public static class WorkerThread extends Thread {
        public WorkerThread(String s) {
            super(workerThreads, s);
        }

        public void run() {
            throw new RuntimeException();
        }

    }

    public static void main(String[] args) {
        Thread t = new WorkerThread("Worker Thread");
        t.start();
    }
}
----------------------------------------------------
----------------------------------------------------


// Thread leakage handling - uncaughtException!!!
public class MainClass implements Runnable {

  static class OverrideThreadGroup extends ThreadGroup {
    public OverrideThreadGroup() {
      super("Administrator Alert Group");
    }

    public void uncaughtException(Thread t, Throwable e) {
      alertAdministrator(e);
    }
  }

  public static void alertAdministrator(Throwable e) {
    // Use Java Mail to send the administrator's pager an email
    System.out.println("Adminstrator alert!");
    e.printStackTrace();
  }

  public static void main(String[] args) {
    ThreadGroup tg = new OverrideThreadGroup();

    Thread t = new Thread(tg, new MainClass());
    t.start();
  }

  public void run() {
    ArrayList al = new ArrayList();
    while (true) {
      al.add(new byte[1024]);
    }
  }
}
----------------------------------------------------
----------------------------------------------------


class MyThread extends Thread {
  boolean stopped;

  MyThread(ThreadGroup tg, String name) {
    super(tg, name);
    stopped = false;
  }

  public void run() {
    System.out.println(Thread.currentThread().getName() + " starting.");
    try {
      for (int i = 1; i < 1000; i++) {
        System.out.print(".");
        Thread.sleep(250);
        synchronized (this) {
          if (stopped)
            break;
        }
      }
    } catch (Exception exc) {
      System.out.println(Thread.currentThread().getName() + " interrupted.");
    }
    System.out.println(Thread.currentThread().getName() + " exiting.");
  }

  synchronized void myStop() {
    stopped = true;
  }
}

public class Main {
  public static void main(String args[]) throws Exception {
    ThreadGroup tg = new ThreadGroup("My Group");

    MyThread thrd = new MyThread(tg, "MyThread #1");
    MyThread thrd2 = new MyThread(tg, "MyThread #2");
    MyThread thrd3 = new MyThread(tg, "MyThread #3");

    thrd.start();
    thrd2.start();
    thrd3.start();

    Thread.sleep(1000);

    System.out.println(tg.activeCount() + " threads in thread group.");

    Thread thrds[] = new Thread[tg.activeCount()];
    tg.enumerate(thrds);
    for (Thread t : thrds)
      System.out.println(t.getName());

    thrd.myStop();

    Thread.sleep(1000);
    
    System.out.println(tg.activeCount() + " threads in tg.");
    tg.interrupt();
  }
}
----------------------------------------------------
----------------------------------------------------


SYNCHRONIZED
------------
public class CrawledSites {
	private List<String> crawledSites = new ArrayList<String>();
	private List<String> linkedSites = new ArrayList<String>();

	public void add(String site) {
		synchronized (this) {
			if (!crawledSites.contains(site)) {
				linkedSites.add(site);
			}
		}
	}
}
----------------------------------------------------
----------------------------------------------------


public class A {
	static void classAction() {
		synchronized (A.class) { // Synchronized block on class A
			// …
		}
	}
}
same as below...


public class A {
	static synchronized  void classAction() {
			// …
	}
}
----------------------------------------------------
----------------------------------------------------


VOLATILE
--------
public class RunnerMisc {
	private static volatile Customer customer = new Customer();
	private static volatile int count = 10;
}
----------------------------------------------------
----------------------------------------------------


JOIN
----
public class ThreadJoinDemo {

	public static void main(String[] args) {
		Thread t1 = new Thread("T1");
		Thread t2 = new Thread("T2");
		try {
			System.out.println("Wait for the child threads to finish.");
			t1.join();	// Current thread is waiting for t1 to finish its execution
			if (!t1.isAlive())
				System.out.println("Thread T1 is not alive.");
			t2.join(); // Current thread is waiting for t2 to finish its execution
			if (!t2.isAlive())
				System.out.println("Thread T2 is not alive.");
		} catch (InterruptedException e) {
			System.out.println("Main Thread interrupted.");
		}
		System.out.println("Exit from Main Thread.");
	}
}
----------------------------------------------------
----------------------------------------------------


class Sleeper extends Thread {
	private int duration;

	public Sleeper(String name, int sleepTime) {
		super(name);
		duration = sleepTime;
		start();
	}

	public void run() {
		try {
			sleep(duration);
		} catch (InterruptedException e) {
			System.out.println(getName() + " was interrupted. " + "isInterrupted(): " + isInterrupted());
			return;
		}
		System.out.println(getName() + " has awakened");
	}
}

class Joiner extends Thread {
	private Sleeper sleeper;

	public Joiner(String name, Sleeper sleeper) {
		super(name);
		this.sleeper = sleeper;
		start();
	}

	public void run() {
		try {
			sleeper.join();
		} catch (InterruptedException e) {
			throw new RuntimeException(e);
		}
		System.out.println(getName() + " join completed");
	}
}

public class Joining {
	public static void main(String[] args) {
		Sleeper sleepy = new Sleeper("Sleepy", 1500), grumpy = new Sleeper("Grumpy", 1500);
		Joiner dopey = new Joiner("Dopey", sleepy), doc = new Joiner("Doc", grumpy);
		grumpy.interrupt();
	}
}
----------------------------------------------------
----------------------------------------------------


// Determining When a Thread Has Finished
// Create and start a thread
Thread thread = new MyThread();
thread.start();

// Check if the thread has finished in a non-blocking way
if (thread.isAlive()) {
    // Thread has not finished
} else {
    // Finished
}

// Wait for the thread to finish but don't wait longer than a
// specified time
long delayMillis = 5000; // 5 seconds
try {
    thread.join(delayMillis);

    if (thread.isAlive()) {
        // Timeout occurred; thread has not finished
    } else {
        // Finished
    }
} catch (InterruptedException e) {
    // Thread was interrupted
}

// Wait indefinitely for the thread to finish
try {
    thread.join();
    // Finished
} catch (InterruptedException e) {
    // Thread was interrupted
}
----------------------------------------------------
----------------------------------------------------


DAEMON THREAD
-------------
// Daemon threads spawn other daemon threads
class Daemon extends Thread {
  private Thread[] t = new Thread[10];

  public Daemon() {
    setDaemon(true);
    start();
  }

  public void run() {
    for (int i = 0; i < t.length; i++)
      t[i] = new DaemonSpawn(i);
    for (int i = 0; i < t.length; i++)
      System.out.println("t[" + i + "].isDaemon() = " + t[i].isDaemon());
    while (true)
      yield();
  }
}

class DaemonSpawn extends Thread {
  public DaemonSpawn(int i) {
    start();
    System.out.println("DaemonSpawn " + i + " started");
  }

  public void run() {
    while (true)
      yield();
  }
}

public class Daemons {

  public static void main(String[] args) throws Exception {
    Thread d = new Daemon();
    System.out.println("d.isDaemon() = " + d.isDaemon());
    // Allow the daemon threads to
    // finish their startup processes:
    Thread.sleep(1000);
  }
}
----------------------------------------------------
----------------------------------------------------

// Daemon threads don't prevent the program from ending.
public class SimpleDaemons extends Thread {
  public SimpleDaemons() {
    setDaemon(true); // Must be called before start()
    start();
  }
  public void run() {
    while(true) {
      try {
        sleep(100);
      } catch (InterruptedException e) {
        throw new RuntimeException(e);
      }
      System.out.println(this);
    }
  }
  public static void main(String[] args) {
    for(int i = 0; i < 10; i++)
      new SimpleDaemons();
  }
}
----------------------------------------------------
----------------------------------------------------


THREAD PRIORITY
---------------
// Shows the use of thread priorities.
public class SimplePriorities extends Thread {
  private int countDown = 5;
  private volatile double d = 0; // No optimization
  public SimplePriorities(int priority) {
    setPriority(priority);
    start();
  }
  public String toString() {
    return super.toString() + ": " + countDown;
  }
  public void run() {
    while(true) {
      // An expensive, interruptable operation:
      for(int i = 1; i < 100000; i++)
        d = d + (Math.PI + Math.E) / (double)i;
      System.out.println(this);
      if(--countDown == 0) return;
    }
  }
  public static void main(String[] args) {
    new SimplePriorities(Thread.MAX_PRIORITY);
    for(int i = 0; i < 5; i++)
      new SimplePriorities(Thread.MIN_PRIORITY);
  }
}
----------------------------------------------------
----------------------------------------------------


class PriThread extends Thread {
  PriThread(String name, int pri) {
    super(name);
    setPriority(pri);
    start();
  }

  public void run() {
    System.out.println(getPriority());
  }
}

public class Main {
  public static void main(String args[]) throws Exception {
    PriThread mt2 = new PriThread("Low Priority", Thread.NORM_PRIORITY - 1);
    PriThread mt1 = new PriThread("High Priority", Thread.NORM_PRIORITY + 1);
    mt1.join();
    mt2.join();
  }
}
----------------------------------------------------
----------------------------------------------------


IMMUTABLE & DEFENSIVE COPIES
----------------------------
public class MyDataStructure {
	List<String> list = new ArrayList<String>();

	public void add(String s) {
		list.add(s);
	}

	public List<String> getList() {
		return Collections.unmodifiableList(list);
	}
}
----------------------------------------------------
----------------------------------------------------


EXECUTOR FRAMEWORK
------------------
public class Main {
	private static final int NTHREDS = 10;

	public static void main(String[] args) {
		ExecutorService executor = Executors.newFixedThreadPool(NTHREDS);
		for (int i = 0; i < 500; i++) {
			Runnable worker = new MyRunnable(10000000L + i);
			executor.execute(worker);
		}
		// This will make the executor accept no new threads
		// and finish all existing threads in the queue
		executor.shutdown();
		// Wait until all threads are finish
		while (!executor.isTerminated()) {

		}
		System.out.println("Finished all threads");
	}
}

public class MyRunnable implements Runnable {
	private final long countUntil;

	MyRunnable(long countUntil) {
		this.countUntil = countUntil;
	}

	@Override
	public void run() {
		long sum = 0;
		for (long i = 1; i < countUntil; i++) {
			sum += i;
		}
		System.out.println(sum);
	}
}
----------------------------------------------------
----------------------------------------------------

Rejected execution handlers and RejectedExecutionException
while (!shutDownRequested()) {
  Socket s = null;
  try {
    s = ss.accept();
    exec.execute(new ConnectionRunnable(s));
  } catch (RejectedExecutionException rej) {
    try { s.close(); } catch (Exception ignore) {}
  } catch (Exception e) {
    // ... log
  }
}


Another way to handle closing the socket is to pass a RejectedExecutionHandler into the constructor of our ThreadPoolExecutor. 
RejectedExecutionHandler is an interface that specifies one method that we must define:
public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
  ...
}
----------------------------------------------------
----------------------------------------------------


FUTURE & CALLABLE
-----------------
public class CallableFutures {
	private static final int NTHREDS = 10;

	public static void main(String[] args) {

		ExecutorService executor = Executors.newFixedThreadPool(NTHREDS);
		List<Future<Long>> list = new ArrayList<Future<Long>>();
		for (int i = 0; i < 20000; i++) {
			Callable<Long> worker = new MyCallable();
			Future<Long> submit = executor.submit(worker);
			list.add(submit);
		}
		long sum = 0;
		System.out.println(list.size());
		// Now retrieve the result
		for (Future<Long> future : list) {
			try {
				sum += future.get();
			} catch (InterruptedException e) {
				e.printStackTrace();
			} catch (ExecutionException e) {
				e.printStackTrace();
			}
		}
		System.out.println(sum);
		executor.shutdown();
	}
}

public class MyCallable implements Callable<Long> {
	@Override
	public Long call() throws Exception {
		long sum = 0;
		for (long i = 0; i <= 100; i++) {
			sum += i;
		}
		return sum;
	}

}
----------------------------------------------------
----------------------------------------------------


ATOMIC INTEGER
--------------
public class Counter {
	private AtomicInteger value = new AtomicInteger(); 
	public int getValue(){
		return value.get();
	}
	public int increment(){
		return value.incrementAndGet();
	}
	
	// Alternative implementation as increment but just make the 
	// implementation explicit
	public int incrementLongVersion(){
		int oldValue = value.get();
		while (value.compareAndSet(oldValue, oldValue+1)){
			 oldValue = value.get();
		}
		return oldValue+1;
	}
}

public class Test {
		private static final int NTHREDS = 10;

		public static void main(String[] args) {
			final Counter counter = new Counter();
			List<Future<Integer>> list = new ArrayList<Future<Integer>>();

			ExecutorService executor = Executors.newFixedThreadPool(NTHREDS);
			for (int i = 0; i < 500; i++) {
				Callable<Integer> worker = new  Callable<Integer>() {
					@Override
					public Integer call() throws Exception {
						int number = counter.increment();
						System.out.println(number );
						return number ;
					}
				};
				Future<Integer> submit= executor.submit(worker);
				list.add(submit);

			}
			
			
			// This will make the executor accept no new threads
			// and finish all existing threads in the queue
			executor.shutdown();
			// Wait until all threads are finish
			while (!executor.isTerminated()) {
			}
			Set<Integer> set = new HashSet<Integer>();
			for (Future<Integer> future : list) {
				try {
					set.add(future.get());
				} catch (InterruptedException e) {
					e.printStackTrace();
				} catch (ExecutionException e) {
					e.printStackTrace();
				}
			}
			if (list.size()!=set.size()){
				throw new RuntimeException("Double-entries!!!"); 
			}
		}
}
----------------------------------------------------
----------------------------------------------------


CYCLIC BARRIER
--------------
public class SimpleThread extends Thread {
	private int countDown = 5;
	private static CyclicBarrier cyclicBarrier;
	private static int threadCount = 0;

	public SimpleThread() {
		super("" + ++threadCount); // Store the thread name
		start();
	}

	public String toString() {
		return "#" + getName() + ": " + countDown;
	}

	public void run() {
		try {
			cyclicBarrier.await();
		} catch (InterruptedException e) {
			e.printStackTrace();
		} catch (BrokenBarrierException e) {
			e.printStackTrace();
		}

		while (true) {
			System.out.println(this);
			if (--countDown == 0)
				return;
		}
	}

	public static void main(String[] args) {
		int numberOfThreads = 5;
		cyclicBarrier = new CyclicBarrier(numberOfThreads);

		for (int i = 0; i < numberOfThreads; i++)
			new SimpleThread();
	}
}
----------------------------------------------------
----------------------------------------------------


CountDownLatch
--------------
public class StopLatchedThread extends Thread {
  private final CountDownLatch stopLatch;
  
  public StopLatchedThread(CountDownLatch stopLatch) {
    this.stopLatch = stopLatch;
  }
  public void run() {
    try {
      // perform interesting task
    } finally {
      stopLatch.countDown();
    }
  }
}

public class Deneme {
	public static void main(String[] args)  throws InterruptedException {
	  CountDownLatch cdl = new CountDownLatch(10);
	  for (int i = 0; i < 10; i++) {
	    Thread t = new StopLatchedThread(cdl);
	    t.start();
	  }
	  cdl.await();
	}
}
----------------------------------------------------
----------------------------------------------------

// Starting threads at the same time
// Useful when you don't know for how many threads to wait
// If you know the number of threads use CyclicBarrier
public class LatchedThread extends Thread {
  private final CountDownLatch startLatch;

  public LatchedThread(CountDownLatch startLatch) {
    this.startLatch = startLatch;
  }
  public void run() {
    try {
      startLatch.await();
      // ... perform task
    } catch (InterruptedException iex) {}
  }
}


CountDownLatch startLatch = new CountDownLatch(1);
for (int threadNo = 0; threadNo < 4; threadNo++) {
  Thread t = new LatchedThread(startLatch);
  t.start();
}
// give the threads chance to start up; we could perform
// initialisation code here as well.
Thread.sleep(200);
startLatch.countDown();
----------------------------------------------------
----------------------------------------------------


TIMER & TIMERTASK
-----------------
// One time scheduled
public class Reminder {
  Timer timer;

  public Reminder(int seconds) {
    timer = new Timer();
    timer.schedule(new RemindTask(), seconds * 1000);
  }

  class RemindTask extends TimerTask {
    public void run() {
      System.out.println("Time's up!");
      timer.cancel(); //Terminate the timer thread
    }
  }

  public static void main(String args[]) {
    System.out.println("About to schedule task.");
    new Reminder(5);
    System.out.println("Task scheduled.");
  }
}

// Repeated and with a delay time to start
public class Reminder {
	Timer timer;

	public Reminder(int seconds) {
		timer = new Timer();
		timer.scheduleAtFixedRate(new RemindTask(), 1000, seconds * 1000);
	}

	class RemindTask extends TimerTask {
		public void run() {
			System.out.println("Working");
		}
	}

	public static void main(String args[]) {
		System.out.println("About to schedule task.");
		new Reminder(5);
		System.out.println("Task scheduled.");
	}
}


// Repeated and with a fixed date start
public class Reminder {
	Timer timer;

	public Reminder(int seconds) {
		timer = new Timer();
		timer.scheduleAtFixedRate(new RemindTask(), DateUtils.addSeconds(new Date(), 1), seconds * 1000);
	}

	class RemindTask extends TimerTask {
		public void run() {
			System.out.println("Working");
		}
	}

	public static void main(String args[]) {
		System.out.println("About to schedule task.");
		new Reminder(5);
		System.out.println("Task scheduled.");
	}
}
----------------------------------------------------
----------------------------------------------------

// Samething is done with thread pool, better approach
public class ScheduleTester {
	public static void main(String[] args) {
		// Get the scheduler
		ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(10);

		// Get a handle, starting now, with a 10 second delay
		final ScheduledFuture<?> scheduledFuture = scheduler.scheduleAtFixedRate(new TimePrinter(System.out), 0, 10, TimeUnit.SECONDS);
		
		// You can sth with scheduledFuture
	}
}

class TimePrinter implements Runnable {
	private PrintStream out;

	public TimePrinter(PrintStream out) {
		this.out = out;
	}

	public void run() {
		out.printf("Current time: %tr%n", new Date());
	}
}
----------------------------------------------------
----------------------------------------------------


DEADLOCK
--------
public class DeadLockExample {

	String o1 = "Lock ";
	String o2 = "Step ";
	Thread t1 = (new Thread("Printer1") {

		public void run() {
			while (true) {
				synchronized (o1) {
					synchronized (o2) {
						System.out.println(o1 + o2);
					}
				}
			}
		}
	});
	Thread t2 = (new Thread("Printer2") {

		public void run() {
			while (true) {
				synchronized (o2) {
					synchronized (o1) {
						System.out.println(o2 + o1);
					}
				}
			}
		}
	});
	public static void main(String[] args) {
		DeadLockExample dLock = new DeadLockExample();
		dLock.t1.start();
		dLock.t2.start();
	}
}
----------------------------------------------------
----------------------------------------------------