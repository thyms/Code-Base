To Cover
--------
- Process vs. Thread
- synchronized, volatile keywords
	- Volatile: Ensures that the variable is loaded from memory before each use, and stored to memory after each use.
	- Synchronized: Ensures that only a single thread can execute a block of code at the same time.
- Immutability & Defensive Copies(both for setting&getting fields)
- Threads & Thread Pools(Executor Framework)
- Runnable(Task), Thread(Worker), Callable(Task), Future(Result), FutureTask
- BlockingLinkedList, Non-BlockingLinkedList
- Thread: suspend, resume, sleep, interrupt, stop(deprecated), wait, notify, notifyAll, isAlive, setDaemon, isDaemon
- ThreadGroup
- Fairness, Starvation & Deadlock
- Selector???
- CyclicBarrier
- Runnable vs. Callable
- AutomicInteger, AutomicLong


Notes
-----

Thread:
- ... provides concurrent and asynchronous behavior. 
- ... is a program's path of execution.
- ... is a single sequential flow of control within a program.
- ... has its own call stack but access shared data.
- ... has its own memory cache.
- Each thread of the same program shares the same data area.
- ... is created by extending Thread or implementing Runnable.
- JVM has a "Thread Scheduler", process according to "Priority" & "Daemon Flag"
executes the thread with highest priority, makes JVM exit if there is no thread or 
only daemon threads.
- "Thread Scheduler" can be either "Preemptive" or "Non-Preemptive". 
Preemptive, each thread has a certain time-slice to execute.
Non-Preemptive, thread executes until it finishes its task.
- In Java, reading and writing a variable is atomic
Except long and double types, they have to be declared as volatile 

Concurrency:
- Running several parts of a program or same part in parallel.

Asynchronous:
- Running part of a program in a asynchronous manner, e.g. responding the request at a later time

Process:
- each has different address space for both and data.
- resources(memory,cpu time) are allocated to it by operating system.


THREAD
------
public class Counter implements Runnable
{
        Thread T;                        
        public void run()                       
        {                              
        ....            
        }
}
----------------------------------------------------
----------------------------------------------------

public class SimpleThread extends Thread {
  private int countDown = 5;
  private static int threadCount = 0;
  public SimpleThread() {
    super("" + ++threadCount); // Store the thread name
    start();
  }
  public String toString() {
    return "#" + getName() + ": " + countDown;
  }
  public void run() {
    while(true) {
      System.out.println(this);
      if(--countDown == 0) return;
    }
  }
  public static void main(String[] args) {
    for(int i = 0; i < 5; i++)
      new SimpleThread();
  }
}
----------------------------------------------------
----------------------------------------------------


Thread myThread = new MyThreadClass();
myThread.start();
try {
    myThread.sleep(10000);
} catch (InterruptedException e){
}
----------------------------------------------------
----------------------------------------------------


Thread myThread = new MyThreadClass();
myThread.start();
try {
    Thread.currentThread().sleep(10000);
} catch (InterruptedException e){
}
----------------------------------------------------
----------------------------------------------------


public class MyRunnable implements Runnable {
	private final long countUntil;

	MyRunnable(long countUntil) {
		this.countUntil = countUntil;
	}

	@Override
	public void run() {
		long sum = 0;
		for (long i = 1; i < countUntil; i++) {
			sum += i;
		}
		System.out.println(sum);
	}
}

public class Main {

	public static void main(String[] args) {
		// We will store the threads so that we can check if they are done
		List<Thread> threads = new ArrayList<Thread>();
		// We will create 500 threads
		for (int i = 0; i < 500; i++) {
			Runnable task = new MyRunnable(10000000L + i);
			Thread worker = new Thread(task);
			// We can set the name of the thread
			worker.setName(String.valueOf(i));
			// Start the thread, never call method run() direct
			worker.start();
			// Remember the thread for later usage
			threads.add(worker);
		}
		int running = 0;
		do {
			running = 0;
			for (Thread thread : threads) {
				if (thread.isAlive()) {
					running++;
				}
			}
			System.out.println("We have " + running + " running threads. ");
		} while (running > 0);

	}
}
----------------------------------------------------
----------------------------------------------------


class TwoThreadsTest {
    public static void main (String args[]) {
        new SimpleThread("Jamaica").start();
        new SimpleThread("Fiji").start();
    }
}
class SimpleThread extends Thread {
    public SimpleThread(String str) {
	super(str);
    }
    public void run() {
	for (int i = 0; i < 10; i++) {
	    System.out.println(i + " " + getName());
            try {
		sleep((int)(Math.random() * 1000));
	    } catch (InterruptedException e) {}
	}
	System.out.println("DONE! " + getName());
    }
}
----------------------------------------------------
----------------------------------------------------


class ProducerConsumerTest {
    public static void main(String args[]) {
	CubbyHole c = new CubbyHole();
	Producer p1 = new Producer(c, 1);
	Consumer c1 = new Consumer(c, 1);

        p1.start();
        c1.start();
    }
}

class Producer extends Thread {
    private CubbyHole cubbyhole;
    private int number;

    public Producer(CubbyHole c, int number) {
	cubbyhole = c;
	this.number = number;
    }

    public void run() {
	for (int i = 0; i < 10; i++) {
	    cubbyhole.put(i);
	    System.out.println("Producer #" + this.number + " put: " + i);
	    try {
	        sleep((int)(Math.random() * 100));
	    } catch (InterruptedException e) {
	    }
	}
    }
}

class Consumer extends Thread {
    private CubbyHole cubbyhole;
    private int number;

    public Consumer(CubbyHole c, int number) {
	cubbyhole = c;
	this.number = number;
    }

    public void run() {
	int value = 0;
	for (int i = 0; i < 10; i++) {
	    value = cubbyhole.get();
	    System.out.println("Consumer #" + this.number + " got: " + value);
	}
    }
}

// It might be better to use "synchronized block here"
// instead of using wait/notify mechanism
class CubbyHole {
    private int seq;
    private boolean available = false;

    public synchronized int get() {
        while (available == false) {
	    try {
			wait();
	    } catch (InterruptedException e) {
	    }
	}
        available = false;
		notify();
		return seq;
    }

    public synchronized void put(int value) {
	while (available == true) {
	    try {
			wait();
	    } catch (InterruptedException e) {
	    }
	}
		seq = value;
        available = true;
        notify();
    }
}
----------------------------------------------------
----------------------------------------------------




THREAD GROUP
------------
ThreadGroup myThreadGroup = new ThreadGroup("My Group of Threads");
Thread myThread = new Thread(myThreadGroup, "a thread for my group");
----------------------------------------------------
----------------------------------------------------


SYNCHRONIZED
------------
public class CrawledSites {
	private List<String> crawledSites = new ArrayList<String>();
	private List<String> linkedSites = new ArrayList<String>();

	public void add(String site) {
		synchronized (this) {
			if (!crawledSites.contains(site)) {
				linkedSites.add(site);
			}
		}
	}
}
----------------------------------------------------
----------------------------------------------------


VOLATILE
--------
public class RunnerMisc {
	private static volatile Customer customer = new Customer();
	private static volatile int count = 10;
}
----------------------------------------------------
----------------------------------------------------


IMMUTABLE & DEFENSIVE COPIES
----------------------------
public class MyDataStructure {
	List<String> list = new ArrayList<String>();

	public void add(String s) {
		list.add(s);
	}

	public List<String> getList() {
		return Collections.unmodifiableList(list);
	}
}
----------------------------------------------------
----------------------------------------------------


EXECUTOR FRAMEWORK
------------------
public class Main {
	private static final int NTHREDS = 10;

	public static void main(String[] args) {
		ExecutorService executor = Executors.newFixedThreadPool(NTHREDS);
		for (int i = 0; i < 500; i++) {
			Runnable worker = new MyRunnable(10000000L + i);
			executor.execute(worker);
		}
		// This will make the executor accept no new threads
		// and finish all existing threads in the queue
		executor.shutdown();
		// Wait until all threads are finish
		while (!executor.isTerminated()) {

		}
		System.out.println("Finished all threads");
	}
}

public class MyRunnable implements Runnable {
	private final long countUntil;

	MyRunnable(long countUntil) {
		this.countUntil = countUntil;
	}

	@Override
	public void run() {
		long sum = 0;
		for (long i = 1; i < countUntil; i++) {
			sum += i;
		}
		System.out.println(sum);
	}
}
----------------------------------------------------
----------------------------------------------------


FUTURE & CALLABLE
-----------------
public class CallableFutures {
	private static final int NTHREDS = 10;

	public static void main(String[] args) {

		ExecutorService executor = Executors.newFixedThreadPool(NTHREDS);
		List<Future<Long>> list = new ArrayList<Future<Long>>();
		for (int i = 0; i < 20000; i++) {
			Callable<Long> worker = new MyCallable();
			Future<Long> submit = executor.submit(worker);
			list.add(submit);
		}
		long sum = 0;
		System.out.println(list.size());
		// Now retrieve the result
		for (Future<Long> future : list) {
			try {
				sum += future.get();
			} catch (InterruptedException e) {
				e.printStackTrace();
			} catch (ExecutionException e) {
				e.printStackTrace();
			}
		}
		System.out.println(sum);
		executor.shutdown();
	}
}

public class MyCallable implements Callable<Long> {
	@Override
	public Long call() throws Exception {
		long sum = 0;
		for (long i = 0; i <= 100; i++) {
			sum += i;
		}
		return sum;
	}

}
----------------------------------------------------
----------------------------------------------------


ATOMIC INTEGER
--------------
public class Counter {
	private AtomicInteger value = new AtomicInteger(); 
	public int getValue(){
		return value.get();
	}
	public int increment(){
		return value.incrementAndGet();
	}
	
	// Alternative implementation as increment but just make the 
	// implementation explicit
	public int incrementLongVersion(){
		int oldValue = value.get();
		while (value.compareAndSet(oldValue, oldValue+1)){
			 oldValue = value.get();
		}
		return oldValue+1;
	}
}

public class Test {
		private static final int NTHREDS = 10;

		public static void main(String[] args) {
			final Counter counter = new Counter();
			List<Future<Integer>> list = new ArrayList<Future<Integer>>();

			ExecutorService executor = Executors.newFixedThreadPool(NTHREDS);
			for (int i = 0; i < 500; i++) {
				Callable<Integer> worker = new  Callable<Integer>() {
					@Override
					public Integer call() throws Exception {
						int number = counter.increment();
						System.out.println(number );
						return number ;
					}
				};
				Future<Integer> submit= executor.submit(worker);
				list.add(submit);

			}
			
			
			// This will make the executor accept no new threads
			// and finish all existing threads in the queue
			executor.shutdown();
			// Wait until all threads are finish
			while (!executor.isTerminated()) {
			}
			Set<Integer> set = new HashSet<Integer>();
			for (Future<Integer> future : list) {
				try {
					set.add(future.get());
				} catch (InterruptedException e) {
					e.printStackTrace();
				} catch (ExecutionException e) {
					e.printStackTrace();
				}
			}
			if (list.size()!=set.size()){
				throw new RuntimeException("Double-entries!!!"); 
			}
		}
}
----------------------------------------------------
----------------------------------------------------


CYCLIC BARRIER
--------------
public class SimpleThread extends Thread {
	private int countDown = 5;
	private static CyclicBarrier cyclicBarrier;
	private static int threadCount = 0;

	public SimpleThread() {
		super("" + ++threadCount); // Store the thread name
		start();
	}

	public String toString() {
		return "#" + getName() + ": " + countDown;
	}

	public void run() {
		try {
			cyclicBarrier.await();
		} catch (InterruptedException e) {
			e.printStackTrace();
		} catch (BrokenBarrierException e) {
			e.printStackTrace();
		}

		while (true) {
			System.out.println(this);
			if (--countDown == 0)
				return;
		}
	}

	public static void main(String[] args) {
		cyclicBarrier = new CyclicBarrier(5);

		for (int i = 0; i < 5; i++)
			new SimpleThread();
	}
}
----------------------------------------------------
----------------------------------------------------

