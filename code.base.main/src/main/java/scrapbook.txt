RowMapper Test
--------------
import org.springframework.jdbc.core.RowMapper;
import com.mockobjects.sql.MockSingleRowResultSet;
import java.util.*;
import org.junit.*;
import static org.junit.Assert.*;
public class PersonRowMapperTest {
    @Test
    public void testMappingRow() throws Exception {
        Person expected = new Person("John", "Doe");
        Map<String, Object> data = new HashMap<String, Object>();    
        data.put("first_name", expected.getFirstName());             
        data.put("last_name", expected.getLastName());               
        MockSingleRowResultSet rs = new MockSingleRowResultSet();    
        rs.addExpectedNamedValues(data);                        
		
        assertEquals(expected, new PersonRowMapper().mapRow(rs, 1));
    }
}

Retry assert for asynch calls
-----------------------------
package com.modeln.junitext;

import junit.framework.AssertionFailedError;

/**
 * This class allows you to assert a condition that may not be true right
 * at the moment, but should become true within a specified time frame.
 * To use it, simply replace calls like:
 * <pre>
 *     assert(someCondition);</pre>
 * With:
 * <pre>
 *     new RetriedAssert(5000, 250) { // timeout, interval
 *         public void run() throws Exception {
 *             assert(someCondition);
 *         }
 *     }.start();</pre>
 *
 * The <code>start()</code> and <code>run()</code> methods were named after 
 * those in <code>java.lang.Thread</code>, whose function they mimic.
 * <p>
 * This class was written by <a href="http://www.modeln.com">Model N, Inc.</a>
 * You may use it and modify it any way you wish--but please leave this 
 * message intact.
 *
 * @author Kevin Bourrillion 
 * &lt;<a href="mailto:kevinb@modeln.com">kevinb@modeln.com</a>&gt;
 */
public abstract class RetriedAssert {

    private int _timeOutMs;
    private int _intervalMs;

    /**
     * Constructor.
     *
     * @param timeOutMs
     * The minimum total length of time, in milliseconds, to try the 
     * assert before giving up and registering the assertion failure 
     * "for real".  This is not treated as a precise upper limit.
     *
     * @param intervalMs
     * The length of time, in milliseconds, to sleep between tries.
     */
    protected RetriedAssert(int timeOutMs, int intervalMs) {
        _timeOutMs = timeOutMs;
        _intervalMs = intervalMs;
    }

    /**
     * Starts the retries.  If your implementation of run() has an 
     * assertion failure, it sleeps and tries again, until the timeout has
     * elapsed, at which time it lets the assertion failure propagate.
     * However, if run() throws another type of Exception, this will be
     * propagated out to the caller immediately.
     */
    public final void start() throws Exception {
        long stopAt = System.currentTimeMillis() + _timeOutMs;

        // Main loop, waiting _intervalMs between tries
        while (System.currentTimeMillis() < stopAt) {
            try {
                run();
                return;
            } catch (AssertionFailedError afe) {
                // Ignore it, we'll try again
            }
            try {
                Thread.sleep(_intervalMs);
            } catch (InterruptedException ie) {
            }
        }

        // All tries have failed so far.  Try one last time, 
        // now letting any failure pass out to the caller.
        run();
    }

    /**
     * Users of this class implement this method to perform the asserts
     * they want.
     */
    public abstract void run() throws Exception;
}


Html, displaying utf-8 characters
---------------------------------
- Put the following at the top of the html pade
<%@ page contentType=”text/html;charset=UTF-8″ %>

Stored Procedure-Oracle
-----------------------
CREATE OR REPLACE PROCEDURE insertDBUSER(
	   p_userid IN DBUSER.USER_ID%TYPE,
	   p_username IN DBUSER.USERNAME%TYPE,
	   p_createdby IN DBUSER.CREATED_BY%TYPE,
	   p_date IN DBUSER.CREATED_DATE%TYPE)
IS
BEGIN
 
  INSERT INTO DBUSER ("USER_ID", "USERNAME", "CREATED_BY", "CREATED_DATE") 
  VALUES (p_userid, p_username,p_createdby, p_date);
 
  COMMIT;
 
END;
/ 

CREATE OR REPLACE PROCEDURE getDBUSERByUserId(
	   p_userid IN DBUSER.USER_ID%TYPE,
	   o_username OUT DBUSER.USERNAME%TYPE,
	   o_createdby OUT  DBUSER.CREATED_BY%TYPE,
	   o_date OUT DBUSER.CREATED_DATE%TYPE)
IS
BEGIN
 
  SELECT USERNAME , CREATED_BY, CREATED_DATE
  INTO o_username, o_createdby,  o_date 
  FROM  DBUSER WHERE USER_ID = p_userid;
 
END;
/

CREATE OR REPLACE PROCEDURE getDBUSERCursor(
	   p_username IN DBUSER.USERNAME%TYPE,
	   c_dbuser OUT SYS_REFCURSOR)
IS
BEGIN
 
  OPEN c_dbuser FOR
  SELECT * FROM DBUSER WHERE USERNAME LIKE p_username || '%';
 
END;
/


Running a command from Java
---------------------------
String[] cmd = { "/bin/sh", "-c", "mycommand > /dev/tty" };
Runtime.getRuntime().exec(cmd);

Loading a resource/properties file
----------------------------------
Properties p = new Properties();
InputStream is = Main.class.getClassLoader().getResourceAsStream("version.properties");
p.load(is);
is.close();
assertEquals(p.getProperty("artifactId") + " " + p.getProperty("version"), Main.getVersionInfo());


Enums
-----
public enum RtcResponseType {
    
    UNKNOWN(-1, "Unknown"), // Temporary
    SUCCESS(0, "Successful Charging"), //
    INSUFFICIENT_CREDIT(1, "Insufficient_Credit"), //
    SUBSCRIBER_NOT_FOUND(2, "Subscriber Not Found"), //Permanent
    SUBSCRIBER_NOT_VALID(3, "Subscriber Not Accepted"), //Permanent
    SUBSCRIBER_PASSSIVE(4, "Subscriber Passive"), //Temporary
    INVALID_OPERATION(5, "Invalid Operation. Must be C or R"), //Permanent
    SYSTEM_ERROR(99, "System Error");//Temporary
    
    private int    returnVal;
    private String description;
    
    private RtcResponseType(int returnVal, String description) {
        this.returnVal = returnVal;
        this.description = description;
    }
    
    public int getReturnVal() {
        return returnVal;
    }
    
    public String getDescription() {
        return description;
    }
    
    public static RtcResponseType getEnum(int returnVal) {
        for (RtcResponseType temp : RtcResponseType.values()) {
            if (temp.getReturnVal() == returnVal) {
                return temp;
            }
        }
        return UNKNOWN;
    }
}
**********************************************************
Enum with Abstract Method
public enum OptionType {
    GUNLUK_30 {
        public String getOptionId() {
            return VrpServiceProperties.OPTION_ID_GUNLUK_30;
        }
    },
    AYLIK_30 {
        public String getOptionId() {
            return VrpServiceProperties.OPTION_ID_AYLIK_30;
        }
    },
    AYLIK_60 {
        public String getOptionId() {
            return VrpServiceProperties.OPTION_ID_AYLIK_60;
        }
    },
    AYLIK_120 {
        public String getOptionId() {
            return VrpServiceProperties.OPTION_ID_AYLIK_120;
        }
    },
    DUNYA_60 {
        public String getOptionId() {
            return VrpServiceProperties.OPTION_ID_DUNYA_60;
        }
    },
    DUNYA_120 {
        public String getOptionId() {
            return VrpServiceProperties.OPTION_ID_DUNYA_120;
        }
    };
    
    public abstract String getOptionId();
}

**********************************************************
Enum.Utils
    public static <T extends Enum<T>> T getEnum(Class<T> enumClass, String name) {
        if (name != null) {
            return Enum.valueOf(enumClass, name);
        }
        return null;
    }
    
    public static <T extends Enum<T>> T getEnum(Class<T> enumClass, Enum<?> enumName) {
        if (enumName != null) {
            return Enum.valueOf(enumClass, enumName.name());
        }
        return null;
    }
    

**********************************************************    
 Groovy SQL
 sql.execute '''
     create table PROJECT (
         id integer not null,
         name varchar(50),
         url varchar(100),
     )
 '''
 
 
subscribers.add(MSISDN: "905431234567", RWM_COUNTRY_ID: 213, COUNTRY_NAME: "Algeria", ATTACH_TIME: 1304208000000, SENDDATE: 1309330796859, FLAG: 0, FLAG_VRP: 0, VODAFONE_OPCO: 1)
********************************************************** 
Groovy Properties file
def props = new Properties()
new File("message.properties").withInputStream { 
  stream -> props.load(stream) 
}
// accessing the property from Properties object using Groovy's map notation
println "capacity.created=" + props["capacity.created"]

def config = new ConfigSlurper().parse(props)
// accessing the property from ConfigSlurper object using GPath expression
println "capacity.created=" + config.capacity.created

If you only use the property file from within Groovy code you should use the Groovy notation variant directly.

def config = new ConfigSlurper().parse(new File("message.groovy").toURL())


Exception Handling Error Log
----------------------------
new Throwable().fillInStackTrace().getStackTrace()[5].getClassName()	// Not Preferable
Thread.currentThread().get StackTrace()[0].getClassName()				// Not Preferable
exception.getStackTrace()	// Preferable


    private String constructLogTextForErrorLevel(String logText, Throwable t, Object... params) {
        StringBuilder messageBuilder = new StringBuilder(this.prefix);
        if (t != null) {
            StackTraceElement stackTrace = t.getStackTrace()[0];
            messageBuilder.append("[")
                          .append(getSimpleClassName(stackTrace.getClassName()))
                          .append("][")
                          .append(stackTrace.getMethodName())
                          .append("][")
                          .append(stackTrace.getLineNumber())
                          .append(sdfLogTraceId)
                          .append(": ");
        }
        
        return messageBuilder.append(MessageFormatter.arrayFormat(logText, params)).toString();
    }
    
    private String getSimpleClassName(String fullClassName) {
        
        if (fullClassName != null) {
            int index = fullClassName.lastIndexOf(".");
            if (index > -1) {
                return fullClassName.substring(fullClassName.lastIndexOf(".") + 1);
            }
        }
        return fullClassName;
    }
    
PL/SQL
------
Package&Procedure
-----------------
create or replace PACKAGE sms_online_sdf
AS
   PROCEDURE sms_olc_sdf (
      pi_msisdn           IN       VARCHAR2,
      pi_destination      IN       VARCHAR2,
      po_return_value     OUT      NUMBER,
      po_return_message   OUT      VARCHAR2
   );
END sms_online_sdf;

create or replace PACKAGE BODY sms_online_sdf
IS
   PROCEDURE sms_olc_sdf (
      pi_msisdn           IN       VARCHAR2,
      pi_destination      IN       VARCHAR2,
      po_return_value       OUT      NUMBER,
      po_return_message   OUT      VARCHAR2,
   )
   IS
   BEGIN
      po_return_value := 0;
      po_return_message := 'Successful Charging';
      IF SUBSTR (pi_msisdn, 1, 12) = '905421000000'
      THEN
         po_return_value := 0;
         po_return_message := 'Successful Charging';
      ELSIF SUBSTR (pi_msisdn, 1, 12) = '905421000001'
      THEN
         po_return_value := 1;
         po_return_message := 'INSUFFICIENT CREDIT';
   END;
END sms_online_sdf;

    
